'use strict';

var _ = require('lodash');
var URI = require('urijs');
var path = require('path');
var VError = require('verror').VError;
var JsonValidator = require('../utils/JsonValidator');
var fsUtils = require('../utils/fs-utils');
var xsAppSchema = require('./schemas/xs-app-schema');
var sourceSchema = require('./schemas/refs/source-schema');
var scopesSchema = require('./schemas/refs/scopes-schema');
var pluginsSchema = require('./schemas/plugins-schema');
var headersSchema = require('./schemas/headers-schema');
var whitelistSchema = require('./schemas/whitelist-schema');
var environmentSchema = require('./schemas/environment-schema');
var envDestinationsSchema = require('./schemas/environment-destinations-schema');
var serviceDestinationsSchema = require('./schemas/service-destinations-schema.json');
var destinationsSchema = require('./schemas/destinations-schema.json');
var approuterOptionsSchema = require('./schemas/options-schema');
var uaaOptionsSchema = require('./schemas/uaa-config-schema');
var corsSchema = require('./schemas/refs/cors-schema');
var connectivitySchema = require('./schemas/connectivity-config-schema');
var html5RepoCredSchema = require('./schemas/html5-repo-credentials-schema');

var destinationConfigSchema = require('./schemas/destinations-srv-config-schema.json');
var xsenv = require('@sap/xsenv');


module.exports = {
  validateXsApp: function (configuration, envDestinations, directory) {
    addConfigurationDefaults(configuration);

    var validator = new JsonValidator();
    validator.addSchema('sourceSchema', sourceSchema);
    validator.addSchema('scopesSchema', scopesSchema);
    validator.addFormat('relative-uri', validateRelativeUri);
    validator.addFormat('local-file', validateLocalFile.bind(null, directory));
    validator.addFormat('uri', validateUri);
    validator.addFormat('regex', validateRegex);
    validator.addFormat('valid-header-value', validateHeaderValue);

    validator.addFormat('route-rules', function (route) {
      if (!route.destination && !route.localDir && !route.service) {
        return 'Route does not have a destination nor a localDir nor a service';
      }

      if (route.destination) {
        if (envDestinations && !envDestinations[route.destination]) {
          return 'Route references unknown destination "' + route.destination + '"';
        }
        if (route.localDir) {
          return 'Route has both localDir and destination';
        }
      }

      if (route.service && route.service === 'html5AppsRepo') {
        try {
          xsenv.cfServiceCredentials({tag: 'html5-apps-repo-rt'});
        } catch (e){
          return 'A route requires html5 applications repository but html5 applications repository runtime service is not bound.';
        }
        if (route.localDir) {
          return 'Route has both localDir and html5AppsRepo';
        }
        if (route.destination) {
          return 'Route has both destination and html5AppsRepo';
        }
      }

      if (route.localDir) {
        var fullPath = path.join(directory, route.localDir);
        if (!fsUtils.isDirectory(fullPath)) {
          return fullPath + ' is not a directory';
        }

        if (Array.isArray(route.httpMethods)) {
          return 'Route has both localDir and httpMethods';
        }
      } else {
        var forbiddenProperties = ['replace', 'cacheControl'];
        for (var i = 0; i < forbiddenProperties.length; i++) {
          if (route[forbiddenProperties[i]]) {
            return 'Route has ' + forbiddenProperties[i] + ' with no localDir';
          }
        }
      }
    });

    validator.addFormat('logout-rules', function (logout) {
      if (logout.logoutPage && !logout.logoutEndpoint) {
        return 'Logout page is set although logout endpoint is not configured';
      }
    });

    validator.validate(configuration, xsAppSchema, 'xs-app.json');

    var routeDestinations = _.map(configuration.routes || [], 'destination').filter(_.identity);
    var unusedDestinations = _.difference(Object.keys(configuration.destinations || {}), routeDestinations);
    if (unusedDestinations.length > 0) {
      throw new VError('Destination(s) "%s" not used by any route', unusedDestinations);
    }
  },

  validateDestinations: function (destinations, withServiceDestinations) {
    var validator = new JsonValidator();
    validator.addFormat('no-duplicate-names', function (destinations) {
      var duplicates = _.chain(destinations).countBy('name').pickBy(function (count) {
        return count > 1;
      }).keys().value();
      if (duplicates.length > 0) {
        return 'Duplicate destination names: ' + duplicates;
      }
    });
    validator.addFormat('valid-port', function (proxyPort) {
      return validatePort(proxyPort, 'Destination "proxyPort"');
    });
    validator.addFormat('absolute-uri', validateAbsoluteUri);
    validator.addSchema('serviceDestinationsSchema', serviceDestinationsSchema);
    validator.addSchema('envDestinationsSchema', envDestinationsSchema);
    if (withServiceDestinations) {
      try {
        validator.validate(destinations, destinationsSchema, 'destinations');
      } catch (e) {
        throw ('One of the defined destinations is invalid' + e);
      }
    } else {
      validator.validate(destinations, envDestinationsSchema, 'environment-destinations');
    }
    validator = this;
    var connectivityCreds;
    destinations.forEach(function (destination) {
      if (withServiceDestinations && destination.authentication === 'PrincipalPropagation' && destination.proxyType === 'Internet') {
        throw 'the destination \"' + destination.name +
                '\" with \"PrincipalPropagation\" authentication type and \"Internet\" proxy type is not supported, ' +
                'please check the destination definition in the destinations service.';
      }
      if (withServiceDestinations && destination.authentication === 'BasicAuthentication' && !destination.user) {
        throw 'the destination \"' + destination.name +
                '\" with \"BasicAuthentication\" authentication missing user and/or password property, ' +
                'please check the destination definition in the destinations service.';
      }
      if (destination.proxyType === 'OnPremise') {
        if (destination.forwardAuthToken) {
          throw 'in destination \"' + destination.name +
                    ' - ForwardAuthToken parameter cannot be used in destinations with proxyType onPremise';
        }
        if (!connectivityCreds) {
          try {
            connectivityCreds = xsenv.cfServiceCredentials({tag: 'connectivity'});
          } catch (e) {
            throw 'destination \"' + destination.name +
                        '\" with  ProxyType \"OnPremise\" but connectivity service is not bound.';
          }
          validator.validateConnectivityCredentials(connectivityCreds);
        }
      }
    });
  }
    ,

  validateEnvironmentSettings: function (configuration) {
    var validator = new JsonValidator();
    validator.addFormat('regexWithCapture', validateRegexWithCapture);
    validator.validate(configuration, environmentSchema, 'environment-settings');
  }
    ,

  validatePlugins: function (configuration, envDestinations) {
    var validator = new JsonValidator();
    validator.addSchema('sourceSchema', sourceSchema);
    validator.addSchema('scopesSchema', scopesSchema);
    validator.addFormat('regex', validateRegex);
    validator.addFormat('relative-uri', validateRelativeUri);

    validator.addFormat('plugin-rules', function (plugin) {
      if (envDestinations && plugin.destination && !envDestinations[plugin.destination]) {
        return 'Plugin references destination "' + plugin.destination + '", which cannot be found in the environment';
      }
    });

    validator.validate(configuration, pluginsSchema, 'plugins');
  }
    ,

  validateHeaders: function (configuration) {
    var validator = new JsonValidator();
    validator.addFormat('valid-header-value', validateHeaderValue);
    validator.addFormat('headers-rules', function (header) {
      var key = Object.keys(header)[0];
      var headerNamePattern = /^[!#$%&'*+\-.^_`|~0-9a-zA-Z]+$/; // http://tools.ietf.org/html/rfc7230#section-3.2.6
      if (!headerNamePattern.test(key)) {
        return 'Header does not have a valid name';
      }

      var headerName = key.match(headerNamePattern)[0];
      if (headerName.toLowerCase() === 'set-cookie' || headerName.toLowerCase() === 'cookie') {
        return 'Headers "set-cookie" and "cookie" are not allowed in the additional headers';
      }
    });

    validator.validate(configuration, headersSchema, 'http-headers');
  }
    ,

  validateWhitelist: function (whitelist) {
    var validator = new JsonValidator();
    validator.addFormat('hostname-rules', function (listItem) {
      var regexHostName = /^(\*\.)?(([a-zA-Z]|[a-zA-Z][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z]|[A-Za-z][A-Za-z0-9\-]*[A-Za-z0-9])$/;
      var regexIPHostName = /^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$/;

      if (!(regexHostName.test(listItem.host) || regexIPHostName.test(listItem.host))) {
        return 'Whitelist item\'s host "' + listItem.host + '" is not correct. Possible values allow valid hostname, IP or hostname prefixed with *.';
      }
    });

    validator.addFormat('valid-port', function (port) {
      return validatePort(port, 'Whitelist item\'s port');
    });

    validator.validate(whitelist, whitelistSchema, 'clickjack-whitelist');
  }
    ,

  validateApprouterStartOptions: function (options) {
    var validator = new JsonValidator();
    validator.addFormat('valid-port', function (port) {
      if (port === 0) {
        return;
      }
      return validatePort(port, 'Approuter port');
    });
    validator.addFormat('function', function functionFormat(data) {
      if (typeof data !== 'function') {
        return 'Function expected';
      }
    });

    validator.validate(options, approuterOptionsSchema, 'options');
  }
    ,

  validateUaaOptions: function (options) {
    var validator = new JsonValidator();
    validator.addFormat('absolute-uri', validateAbsoluteUri);

    validator.validate(options, uaaOptionsSchema, 'uaa-configuration');
  }
    ,


  validateConnectivityCredentials: function (options) {
    var validator = new JsonValidator();
    validator.addFormat('absolute-uri', validateAbsoluteUri);

    validator.validate(options, connectivitySchema, 'connectivity-configuration');

  }
    ,

  validateHTML5AppsRepoCredentials: function (options) {
    var validator = new JsonValidator();
    validator.addFormat('absolute-uri', validateAbsoluteUri);

    validator.validate(options, html5RepoCredSchema, 'html5-repo-credentials');

  }
    ,

  validateDestinationCredentials: function (options) {
    var validator = new JsonValidator();
    validator.addFormat('absolute-uri', validateAbsoluteUri);

    validator.validate(options, destinationConfigSchema, 'destination-service-credentials-configuration');
  }
    ,

  validateCors: function (options) {
    var validator = new JsonValidator();
    validator.addFormat('regex', validateRegex);
    validator.addFormat('validateWhitelist', exports.validateWhitelist);
    validator.addSchema('sourceSchema', sourceSchema);
    validator.validate(options, corsSchema, 'cors-configuration');
  }
}
;

function addConfigurationDefaults(configuration) {
  var defaultSessionTimeoutInMinutes = 15;
  var defaultLoginCallback = '/login/callback';
  var websocketsEnabledByDefault = false;
  var compressionEnabledByDefault = true;

  _.defaultsDeep(configuration, {compression: {enabled: compressionEnabledByDefault}});
  configuration.sessionTimeout = configuration.sessionTimeout || defaultSessionTimeoutInMinutes;
  configuration.login = getPropertyValue(configuration, 'login', {callbackEndpoint: defaultLoginCallback});
  configuration.websockets = getPropertyValue(configuration, 'websockets', {enabled: websocketsEnabledByDefault});
}

function getPropertyValue(configObject, propertyName, defaultValue) {
  if (configObject.hasOwnProperty(propertyName)) {
    return configObject[propertyName];
  }
  return defaultValue;
}

function validateRelativeUri(relativeUri) {
  var components = URI.parse(relativeUri);
  if (components.protocol || components.hostname) {
    return 'URI must be a relative path';
  }
}

function validateLocalFile(directory, file) {
  var fullPath = path.join(directory, file);
  if (!fsUtils.isFile(fullPath)) {
    return fullPath + ' is not a file';
  }
}

function validateAbsoluteUri(uri) {
  var components = URI.parse(uri);
  if (!components.protocol || !components.hostname) {
    return 'URI must be absolute';
  }
  var supportedProtocols = ['http', 'https', 'ws', 'wss'];
  if (!_.includes(supportedProtocols, components.protocol)) {
    return 'URI has unsupported protocol, supported protocols are ' + supportedProtocols;
  }
}

function validateUri(uri) {
  var components = URI.parse(uri);
  if (components.protocol && components.protocol !== 'http' && components.protocol !== 'https') {
    return "Supported schemes are 'http' and 'https'";
  }
}

function validateRegex(regex) {
  var regexToCheck = _.isObject(regex) ? regex.path : regex;
  try {
    RegExp(regexToCheck);
  } catch (exception) {
    return exception;
  }
}

function validateRegexWithCapture(regex) {
  var regexError = validateRegex(regex);
  if (regexError) {
    return regexError;
  }
  if (regex.indexOf('(') === -1) {
    return 'regular expression must contain a capturing group';
  }
}

function validatePort(port, messagePrefix) {
  var portMinValue = 1;
  var portMaxValue = 65535;
  if (typeof port === 'string' && !/^[1-9]\d*$/.test(port)) {
    return messagePrefix + ' value is string, which cannot be parsed as positive integer';
  }
  port = parseFloat(port);
  if (port < portMinValue || port > portMaxValue) {
    return messagePrefix + ' value has to be string or integer between ' + portMinValue + '-' + portMaxValue;
  }
}

function validateHeaderValue(headerValue) {
    // Inspired by Node.js: https://github.com/nodejs/node/blob/master/lib/_http_outgoing.js
  var headerValueIsValid = headerValue.split('').map(function (character) {
    return character.charCodeAt(0);
  }).every(function (charCode) {
    return (charCode > 31 && charCode <= 255 && charCode !== 127) || charCode === 9;
  });

  if (!headerValueIsValid) {
    return 'The header content contains invalid characters';
  }
}
