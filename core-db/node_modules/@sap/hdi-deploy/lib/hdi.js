'use strict';

/* jslint indent: 4 */

var async = require('async');
var path = require('path');
var fs = require('fs');
var utils = require('./utils.js');

var hdbAsync = require('./hdbAsync.js');
var hdiClient = require('./node-hdi/node-hdi.js');
var logger = require('./logger.js');
var messages_hdi = require('./messages.hdi.js');

var deployId = process.env.DEPLOY_ID || 'Deployment ID: none';

// deploy hdi content
exports.deploy = function(options, creds, content, cb) {
    var hdiCreds = {
        user: creds.hdi_user ? creds.hdi_user : creds.user,
        password: creds.hdi_user ? creds.hdi_password : creds.password,
    };

    if (Array.isArray(creds.db_hosts)) {
        hdiCreds.hosts = creds.db_hosts;
    } else {
        hdiCreds.host = creds.host;
        hdiCreds.port = creds.port;
    }

    if (creds.certificate) {
        hdiCreds.ca = Array.isArray(creds.certificate) ? creds.certificate : [ creds.certificate ];
        logger.trace('hdiCreds.ca set to', hdiCreds.ca);
    }

    hdiCreds.initializationTimeout = options.connectionTimeout;

    var printMessages = hdbAsync().printMessages;
    function logfn(messages) {
        printMessages(logger, messages);
    }

    //var client = new hdiClient(creds.schema, function(messages) { logfn(logger, messages); }, hdiCreds);
    var client = new hdiClient(creds.schema, null, hdiCreds); // no logging inside node-hdi-client
    var deployContent;
    var tasks = [];
    var serverTopDirs = content.serverTopDirs() || [];
    var deployFiles = [];
    var undeployFiles = [];

    function filterUndeploy(undeployFiles) {
        var filename = path.join(options.root, options.undeployFilename);
        var filter = [];

        if (fs.existsSync(filename)) {
            logger.log('Undeploy whitelist file "undeploy.json" found; deleted files will be filtered by the whitelist');
            filter = utils.readJSONFile(filename);

            return undeployFiles.filter(function(file) {
                return filter.indexOf(file) !== -1;
            });
        } else {
            logger.log('Undeploy whitelist file "undeploy.json" not found; an empty whitelist is used and no files will be scheduled for undeploy');
            return [];
        }
    }


    function prepareMake(result) {
        if (options.treatUnmodifiedAsModified) {
            // schedule all locally collected files for deploy; this maps to Added, Modified, or Unmodified
            deployFiles = content.deployFiles().map(function(item) { return item[0]; });
        } else {
            // schedule the Added or Modified files for deploy
            deployFiles = result.filter(function(item) { return item.STATUS === 'A' || item.STATUS === 'M'; })
                                .map(function(item) { return item.PATH; });
        }
        undeployFiles = result.filter(function(item) { return item.STATUS === 'D'; })
                              .map(function(item) { return item.PATH; });

        logger.trace('status result:', result);
        logger.trace('deploy files:', deployFiles);
        logger.trace('undeploy files:', undeployFiles);

        // filter the undeploy set based on the undeploy.json file
        if (undeployFiles.length && !options.autoUndeploy) {
            undeployFiles = filterUndeploy(undeployFiles);
            logger.trace('filtered undeploy files:', undeployFiles);
        }

        // filter the undeploy set by the include-filter, because deleted files are not considered during the file walk
        if (options.includeFilter.valid) {
            undeployFiles = undeployFiles.filter(function(file) {
                return options.includeFilter.matchesPath(file);
            });
        }

        // filter current deployFiles and undeployFiltes via the working set
        if (options.workingSet.valid) {
            deployFiles = deployFiles.filter(function (file) {
                return options.workingSet.matchesPath(file);
            });

            undeployFiles = undeployFiles.filter(function (file) {
                return options.workingSet.matchesPath(file);
            });
        }

        if (options.treatUnmodifiedAsModified) {
            logger.log(deployFiles.length + " modified, unmodified, or added files are scheduled for deploy");
        } else {
            logger.log(deployFiles.length + " modified or added files are scheduled for deploy based on delta detection");
        }
        logger.log(undeployFiles.length + " deleted files are scheduled for undeploy based on delta detection (filtered by undeploy whitelist)");

        // add explicit deploy set, but filter it via the working set
        var options_deploy_count = 0;
        options.deploy.forEachFile(function(path) {
            if (options.workingSet.matchesPath(path)) {
                deployFiles.push(path);
                options_deploy_count++;
            }
        });

        // add explicit undeploy set, but filter it via the working set
        var options_undeploy_count = 0;
        options.undeploy.forEachFile(function(path) {
            if (options.workingSet.matchesPath(path)) {
                undeployFiles.push(path);
                options_undeploy_count++;
            }
        });

        logger.log(options_deploy_count + " files are scheduled for deploy based on explicit specification");
        logger.log(options_undeploy_count + " files are scheduled for undeploy based on explicit specification");

        return { deployFiles : deployFiles,
	             undeployFiles : undeployFiles };
    }


    logger.trace(serverTopDirs);

    logger.logTimerInit('preprocessing-files', 'Preprocessing files...');
    try {
        deployContent = content.deployContent();
    } catch (err) {
        cb(err);
        return;
    }
    logger.logTimerDelta('preprocessing-files', 'Preprocessing files... ok');

    tasks.push(logger.logfnTimerInit('connect-container', 'Connecting to the container "%s"...', creds.schema));
    tasks.push(function(callback) { client.connect(callback); });
    tasks.push(logger.logfnTimerDelta('connect-container', 'Connecting to the container "%s"... ok', creds.schema));

    if (options.lockContainer) {
        tasks.push(logger.logfnTimerInit('locking-container', 'Locking the container "%s"...', creds.schema));
        tasks.push(function(callback) { client.lock(options.lockContainerTimeout, {}, callback); });
        tasks.push(logger.logfnTimerDelta('locking-container', 'Locking the container "%s"... ok', creds.schema));
    }

    tasks.push(logger.logfnTimerInit('synchronizing-files', 'Synchronizing files with the container "%s"...', creds.schema));

    if (options.singleDeleteCallsForDirectories)Â {
        serverTopDirs.forEach(function(dir) {
            tasks.push(function(callback) {
                async.waterfall([
                    function(innerCB) { client.delete(dir, { RECURSIVE : 'TRUE' }, innerCB); },
                    function(result, innerCB) {
                        if (result.RETURN_CODE >= 0) {
                            // don't log anything
                            return innerCB(null, result);
                        }

                        var messages = result.MESSAGES;
                        var expectedErrors = [ messages_hdi.DELETE_PATHS_FAILED.code, messages_hdi.FOLDER_NOT_FOUND.code ];
                        var foundErrorCodes = 0;

                        for (var i = 0; i < expectedErrors.length; ++i) {
                            for (var j = 0; j < messages.length; ++j) {
                                if (messages[j].MESSAGE_CODE === expectedErrors[i]) {
                                    ++foundErrorCodes;
                                    break;
                                }
                            }
                        }

                        if (foundErrorCodes === expectedErrors.length) {
                            // don't log anything
                            return innerCB(null, result);
                        }
                        logfn(result.MESSAGES);
                        innerCB(new Error('HDI call failed'));
                    }
                ], callback);
            });
        });
    } else {
        tasks.push(function(callback) { client.delete(serverTopDirs.map(function(a) { return a[0]; }), { RECURSIVE : 'TRUE', IGNORE_NON_EXISTING_PATHS : 'TRUE' }, callback); });
    }

    tasks.push(function(callback) { client.write(deployContent, {}, callback); });
    tasks.push(logger.logfnTimerDelta('synchronizing-files', 'Synchronizing files with the container "%s"... ok', creds.schema));

    var deployParameters = {};
    // copy parameters from options
    Object.keys(options.parameters).forEach(function(key) {
        deployParameters[key.toUpperCase()] = options.parameters[key];
    });
    // add explicit parameters
    if (options.treatWarningsAsErrors) {
        deployParameters.TREAT_WARNINGS_AS_ERRORS = 'TRUE';
    }
    if (options.simulateMake) {
        deployParameters.SIMULATE_MAKE = 'TRUE';
    }

    tasks.push(function(callback) {
        async.waterfall([
            function(innerCB) { client.status(serverTopDirs.map(function(a) { return a[0]; }), {}, innerCB); },
            function(result, innerCB) {
                var fileLists = prepareMake(result.RESULTS);
                deployFiles = fileLists.deployFiles;
                undeployFiles = fileLists.undeployFiles;
                return innerCB(null, deployFiles, undeployFiles);
            },
            function(deployFiles, undeployFiles, innerCB) {
                logger.logTimerInit('deploying-files', 'Deploying to the container "%s"...', creds.schema);
                client.make(deployFiles, undeployFiles, {}, deployParameters, innerCB);
            },
            function(result, innerCB) {
                logfn(result.MESSAGES);
                if (result.RETURN_CODE < 0) {
                    innerCB(new Error('HDI make failed'), result);
                } else {
                    innerCB(null, result);
                }
            }
        ], callback);
    });

    tasks.push(logger.logfnTimerDelta('deploying-files', 'Deploying to the container "%s"... ok', creds.schema));

    tasks.push(function(callback) {
        var defaultAccessRoleFile = 'src/defaults/default_access_role.hdbrole';
        var defaultAccessRoleName = 'default_access_role';
        var containerAccessRoleName = creds.schema + "::access_role";

        var defaultPermissionSet = [
            ['CREATE TEMPORARY TABLE', '', containerAccessRoleName],
            ['DELETE',                 '', containerAccessRoleName],
            ['EXECUTE',                '', containerAccessRoleName],
            ['INSERT',                 '', containerAccessRoleName],
            ['SELECT',                 '', containerAccessRoleName],
            ['SELECT CDS METADATA',    '', containerAccessRoleName],
            ['UPDATE',                 '', containerAccessRoleName]
        ];

        if (undeployFiles.indexOf(defaultAccessRoleFile) !== -1 && deployFiles.indexOf(defaultAccessRoleFile) === -1) {
            if (options.simulateMake) {
                logger.log('Default-access-role file "src/defaults/default_access_role.hdbrole" undeployed, but simulate-make option was given; global role "%s" will not be adapted', containerAccessRoleName);
                callback();
            } else {
                async.series([
                    logger.logfn('Default-access-role file "src/defaults/default_access_role.hdbrole" undeployed; global role "%s" will be adapted', containerAccessRoleName),
                    logger.logfnTimerInit('regrant-default-permissions', 'Regranting default permission set to global role "%s"...', containerAccessRoleName),
                    function(cb) { client.grantContainerSchemaPrivileges(defaultPermissionSet, {}, cb); },
                    logger.logfnTimerDelta('regrant-default-permissions', 'Regranting default permission set to global role "%s"... ok', containerAccessRoleName)
                ], callback);
            }
        } else {
            if (content.containsDefaultAccessRoleFile()) {
                if (options.simulateMake) {
                    logger.log('Default-access-role file "src/defaults/default_access_role.hdbrole" scheduled for deploy, but simulate-make option was given; global role "%s" will not be adapted', containerAccessRoleName);
                    callback();
                } else {
                    async.series([
                        logger.logfn('Default-access-role file "src/defaults/default_access_role.hdbrole" scheduled for deploy; global role "%s" will be adapted', containerAccessRoleName),
                        logger.logfnTimerInit('grant-default-role', 'Granting container-local default access role "%s"."%s" to global role "%s"...', creds.schema, defaultAccessRoleName, containerAccessRoleName),
                        function(cb) { client.grantContainerSchemaRoles([[defaultAccessRoleName, '', containerAccessRoleName]], {}, cb); },
                        logger.logfnTimerDelta('grant-default-role', 'Granting container-local default access role "%s"."%s" to global role "%s"... ok', creds.schema, defaultAccessRoleName, containerAccessRoleName),

                        logger.logfnTimerInit('revoke-default-permissions', 'Revoking default permission set from global role "%s"...', containerAccessRoleName),
                        function(cb) { client.revokeContainerSchemaPrivileges(defaultPermissionSet, {}, cb); },
                        logger.logfnTimerDelta('revoke-default-permissions', 'Revoking default permission set from global role "%s"... ok', containerAccessRoleName)
                    ], callback);
                }
            } else {
                logger.log('No default-access-role handling needed; global role "%s" will not be adapted', containerAccessRoleName);
                callback();
            }
        }
    });

    if (options.lockContainer) {
        tasks.push(logger.logfnTimerInit('unlocking-container', 'Unlocking the container "%s"...', creds.schema));
        tasks.push(function(callback) { client.unlock(callback); });
        tasks.push(logger.logfnTimerDelta('unlocking-container', 'Unlocking the container "%s"... ok', creds.schema));
    }

    // unleash the avalanche
    async.series(tasks, function(err, results) {
        if (err) {
            // err.message.replace: delete line breaks
            var message = err.message ? '' + err.message : '' + err;
            logger.error('Deployment to container %s failed - error: %s [%s].', creds.schema, message.replace(/(\r\n|\n|\r)/gm, ''), deployId);
        } else {
            logger.log('Deployment to container %s done [%s].', creds.schema, deployId);
        }

        // as last action, close the client
        client.close();

        cb(err, {
            task: 'deploy',
            results: results
        });
    });
};
